# @author mia liu
# Import base module(s):
import os.path
import time
import sys
import optparse
# Import PyROOT:
import ROOT
import re
## 
# @ this is a function written based on sframe_input file, but read in the 
# original number of events in the cutflow histogram since most samples are heavly skimmed.
# 
#short Function creating <In /> configuration nodes for MC input
#
# The function checks the specified input files and writes the XML nodes
# with their information to the specified output file. Their luminosity
# is calculated using the specified cross section.
#
# @param crossSection Cross section of the Monte Carlo
# @param files        List of input files
# @param output       Name of the output file
# @param tree         Name of the main TTree in the files
# @param prefix       Prefix to be put before the file paths.
#                     E.g. root://mymachine/
# @param real_filenames Boolean flag specifying if the file names are good as
#                       they are (no absolute path name lookup needed)
# @returns <code>0</code> if successful, something else if not
def CreateInput( crossSection, files, listofsamples ,output, tree, output_tree,prefix, real_filenames ):

  # Turn off ROOT error messages:
  oldErrorIgnoreLevel = ROOT.gErrorIgnoreLevel
  ROOT.gErrorIgnoreLevel = ROOT.kSysError

  # Open the output file:
  outfile = open( output, "w" )

  # Print some header in the output text file:
  outfile.write( "<!-- File generated by SFrameHelpers.CreateInput(...) on %s -->\n" % \
                 time.asctime( time.localtime( time.time() ) ) )
  outfile.write( "<!-- The supplied x-section was: %f -->\n\n" % crossSection )

  # Some summary values:
  totEvents = 0
  totLuminosity = 0.0

  # Loop over all the files:
  for file in files:

    # Print some status messages:
    print "Processing file: %s" % os.path.basename( file )

    # Open the AANT file:
    tfile = ROOT.TFile.Open( file )
    if not tfile.IsOpen():
      print "*ERROR* File \"" + file + "\" does not exist *ERROR*"
      return 255
    
    # Access a tree in the ntuple:
    collTree = tfile.Get( tree  )
    if( str( collTree ) == 'None' ):
      print "*ERROR* " + tree + "  not found in file: \"" + file + "\" *ERROR*"
      continue
    # Access cutflow histogram in the ntuple:
    cutflow = tfile.Get('cf')
    #events = cutflow.GetBinContent(1)
    # Read the number of events in the file:
    #events = collTree.GetEntries()

    # Open a txt file that contain cross sections
    samples = open(listofsamples)
    runnumber = os.path.basename( file ).split('.')[0]
    xsec = None
    kfactor = None
    filter_eff = None
    events = None
    for line in samples:
        if not line.strip() or line.startswith("#"):
           continue
        if runnumber in line:
           xsec = float( line.split()[2])
           events = float( line.split()[-1])
           if 'N' not in line.split()[3]:           
               kfactor = float( line.split()[3])
           else:
               kfactor = 1
           filter_eff = float( line.split()[4])
           continue
    if not xsec:
       print "*ERROR* File \"" + file + "\" is not in the sample list *ERROR*"
       return 255
    # calculate corresponding cross section
    luminosity = float( events ) / (xsec*kfactor*filter_eff)

    # Increment the summary variables:
    totEvents = totEvents + events
    totLuminosity = totLuminosity + luminosity

    # Compose the XML node. Make sure that the file name has an absolute path
    # (no symbolic link, or relative path) and that the luminosity is printed with
    # a meaningful precision.
#    if real_filenames:
#      outfile.write( "<In FileName=\"" + prefix + file + \
#                     ( "\" Lumi=\"%.3g" % luminosity ) + "\" />\n" )
#    else:
    outfile.write( '<InputData Lumi="" NEventsMax="-1" Type="MC" Version="'+os.path.basename( file ).split('.')[0]+'.alljets">\n')
    outfile.write( "  <In FileName=\"" + prefix + \
                    os.path.abspath( os.path.realpath( file ) ).replace('/afs/cern.ch/user/m/mliu/eos/','root://eosatlas.cern.ch//eos/') + \
                     ( "\" Lumi=\"%.3g" % luminosity ) + "\" />\n" )
    outfile.write( '  <InputTree Name="'+tree+'" '+r'/>'+'\n')
    outfile.write( '  <OutputTree Name="'+output_tree+'" '+r'/>'+'\n')
    outfile.write( r'</InputData>'+'\n')
    # Close the opened input file:
    tfile.Close()

  # Save some summary information:
  outfile.write( "\n<!-- Total number of events processed: %s -->\n" % totEvents )
  outfile.write( "<!-- Representing a total luminosity : %.3g -->" % totLuminosity )

  # Close the output file:
  outfile.close()

  # Print some summary information:
  print "\nTotal number of events processed: %s" % totEvents
  print "Representing a total luminosity : %.3g\n" % totLuminosity

  # Turn back ROOT error messages:
  ROOT.gErrorIgnoreLevel = oldErrorIgnoreLevel

  return 0

##
# @short Function creating <In /> configuration nodes for data input
#
# The function checks the specified input files and writes the XML nodes
# with their information to the specified output file. It assumes that the
# input files are data files, so it just puts a dummy "1.0" as the
# luminosity for them. (The luminosities are disregarded in the event
# weight calculation when the InputData type is set to "data".)
#
# @param files        List of input files
# @param output       Name of the output file
# @param tree         Name of the main TTree in the files
# @param prefix       Prefix to be put before the file paths.
#                     E.g. root://mymachine/
# @param real_filenames Boolean flag specifying if the file names are good as
#                       they are (no absolute path name lookup needed)
# @returns <code>0</code> if successful, something else if not
def CreateDataInput( files, output, tree, prefix, real_filenames ):

  # Turn off ROOT error messages:
  oldErrorIgnoreLevel = ROOT.gErrorIgnoreLevel
  ROOT.gErrorIgnoreLevel = ROOT.kSysError

  # Open the output file:
  outfile = open( output, "w" )

  # Print some header in the output text file:
  outfile.write( "<!-- File generated by SFrameHelpers.CreateDataInput(...) on %s -->\n\n" % \
                 time.asctime( time.localtime( time.time() ) ) )

  # Some summary values:
  totEvents = 0

  # Loop over all the files:
  for file in files:

    # Print some status messages:
    print "Processing file: %s" % os.path.basename( file )

    # Open the AANT file:
    tfile = ROOT.TFile.Open( file )
    if ( not tfile ) or ( not tfile.IsOpen() ):
      print "*ERROR* File \"" + file + "\" does not exist *ERROR*"
      return 255

    # Access a tree in the ntuple:
    collTree = tfile.Get( tree )
    if( str( collTree ) == 'None' ):
      print "*ERROR* " + tree + " not found in file: \"" + file + "\" *ERROR*"
      continue

    # Read the number of events in the file:
    events = collTree.GetEntries()

    # Increment the summary variables:
    totEvents = totEvents + events

    # Compose the XML node. Make sure that the file name has an absolute path
    # (no symbolic link, or relative path) and that the luminosity is printed with
    # a meaningful precision.
    if real_filenames:
      outfile.write( "<In FileName=\"" + prefix + file + \
                     "\" Lumi=\"1.0\" />\n" )
    else:
      outfile.write( "<In FileName=\"" + prefix + \
                     os.path.abspath( os.path.realpath( file ) ) + \
                     "\" Lumi=\"1.0\" />\n" )

    # Close the opened input file:
    tfile.Close()

  # Save some summary information:
  outfile.write( "\n<!-- Total number of events processed: %s -->\n" % totEvents )

  # Close the output file:
  outfile.close()

  # Print some summary information:
  print "\nTotal number of events processed: %s" % totEvents

  # Turn back ROOT error messages:
  ROOT.gErrorIgnoreLevel = oldErrorIgnoreLevel

  return 0

def main():
  # Print some welcome message before doing anything else:
  print ">>"
  print ">> %s : <In> node creator for SFrame analysis jobs" % \
        os.path.basename( sys.argv[ 0 ] )
  print ">>"
  print ""

  # Parse the command line parameters:
  parser = optparse.OptionParser( usage="%prog [options] <input files>" )
  parser.add_option( "-x", "--xsection", dest="xsection",
                     action="store", type="float", default=1.0,
                     help="Cross-section of the MC (for instance in pb)" )
  parser.add_option( "-d", "--data", dest="data",
                     action="store_true",
                     help="The input files are DATA" )
  parser.add_option( "-o", "--output",  dest="output",
                     action="store", type="string", default="data.xml",
                     help="Output XML file" )
  parser.add_option( "-s", "--sampleinfo",  dest="sampleinfo",
                     action="store", type="string", default="data.txt",
                     help="Text file with sample information" )
  parser.add_option( "-t", "--tree", dest="tree",
                     action="store", type="string", default="CollectionTree",
                     help="TTree name in the files" )
  parser.add_option( "--ot", "--outputtree", dest="output_tree",
                     action="store", type="string", default="CollectionTree",
                     help="TTree name in the output files" )
  parser.add_option( "-p", "--prefix", dest="prefix",
                     action="store", type="string", default="",
                     help="Prefix to be put before the absolute path" )
  parser.add_option( "-r", "--real-filenames", dest="real_filenames",
                     action="store_true",
                     help="The file names should not be modified by the script" )

  ( options, files ) = parser.parse_args()

  # Check that at least one file is specified:

  if not len( files ):
    print "You should define at least one input file!"
    print ""
    parser.print_help()
    return 255

  # To avoid a PyROOT bug the script receives "-" as the first argument when being
  # executed on the GRID. This argument should just be ignored by the script...
  if "-" in files:
    files.remove( "-" )

  # On Panda the list of input files is given as a comma separated list.
  # While it is possible to transform that list into a space separated list
  # outside of this script, it is very conventient if this script can handle
  # such inputs as well.
  if ( len( files ) == 1 ) and files[ 0 ].count( ',' ):
    files = files[ 0 ].split( ',' )

  # Switch ROOT to batch mode:
  import ROOT
  ROOT.gROOT.SetBatch()

  print "The input files are Monte Carlo files"
  print ""
  return CreateInput( options.xsection, files, options.sampleinfo ,options.output, options.tree,options.output_tree,
                                      options.prefix, options.real_filenames )

# Call the main function:
if __name__ == "__main__":
  sys.exit( main() )
